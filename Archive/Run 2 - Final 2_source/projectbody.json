{"main":"# MicroPython classes           # Google: what is a python class\n# here we only import parts     # Google: python what is importing?\n# of the time object\nfrom time import ticks_ms       # Google: python time.ticks_ms\nfrom time import sleep          # Google: python time.sleep\nfrom sys import exit\n\n\n# spike classes       \nfrom hub import port            # Hub Port enums\nfrom hub import motion_sensor\nfrom hub import light\nfrom hub import light_matrix\nfrom hub import button\nimport motor\nimport motor_pair\nfrom app import linegraph\nfrom app import display         # use in my test methods\n\nimport distance_sensor       \nimport color_sensor          \nimport color                    # color enums\n\n####################################################\n# gyro drive globals \n# Google: python global\n####################################################\n\nglobal Drive                                        # add any global settings                                  \n\n##################################################\n# Gyro Drive Enum \n# Associate a name with a number\n##################################################\nclass log_level:      \n    OFF     = 0                                     # no normal log\n    PROBLEM = 1                                     # only porblems\n    END     = 2                                     # method end messages\n    STEP    = 3                                     # method step messages\n    START   = 4                                     # method start messages\n    ALL     = 5                                     # all general messages\n\nclass motor_velocity:\n    SPIKE_SMALL_MOTOR= 660                          # definitions found under spike motor run method\n    SPIKE_MEDIUM_MOTOR = 1110                       # see the Spike knowledge base to the right -->\n    SPIKE_LARGE_MOTOR= 1050                         # add any others below\n\nclass results:                                      # larger numbers to see big deflects in the plot\n    PROBLEM           = -1                          # If a problem happens. Will also throw an exception. \n    CODE_RESET        = 0                           # this is reset at the beginning of the gyro_drive functions\n    TARGET_REACHED    = 1                           # robot achieved the desired target\n    WAYPOINT_DETECTED = 2                           # Did the robot see the optional waypoint?\n    TIMED_OUT         = 3                           # gyro_drive reached the optional timeout\n    RUNNING           = 4                           # This way if a mission failed, you can decided\n                                                    # what you want the robot to do. Maybe drive back to base\n\n\n####################################################\n# main definition all python coode starts here\n####################################################\ndef main():                                         # this is the main function. The code will flow top\n                                                    # to bottom. \n\n    global Drive, front_lift                        # Captures Drive and front_lift above as global in main\n    #global back_lift, my_little_pony_lift          # You can put them on seperate lines. \n\n    # build the settings class, now called Drive.  # there are other values that you manually set. \n    Drive = gyro_drive_settings(5.57,               # wheel diameter, adjust as you need for accuracy\n                                port.A,             # left motor port\n                                port.E,             # right motor port\n                                port.E,             # measure motor port, normally drives forward\n                motor_velocity.SPIKE_MEDIUM_MOTOR)   # motors max velocity, Knowledge Base \n    \n    Drive.logging_level = log_level.ALL             # will shut off logging, more to coem about my logging\n    Drive.log_source_filter = ''                    # defined a lof handle filter, '' is no filter. \n\n    #Drive.use_linegraph = True                     # True turns on plotting if movement support this\n    if Drive.use_linegraph == True:                 # What does this say? easy to understand.\n        linegraph.clear_all()                       # read about linegraph under app in Knowledge Base\n\n    motor_pair.pair(Drive.motor_pair_id,            # Drive motors are assigned to motor_pair\n                    Drive.motor_port_left,          # we use motor_pair on our drive motors\n                    Drive.motor_port_right)         # with this we can start and stop them together.\n\n                                                    # Tests Remove or comment out when done testing\n    #tests = gyro_drive_tests(speed=100, loops=1)            # on a new line type tests. to see the available tests\n    #tests.yaw_demo(180)                             # turn robot to see yaw and correction.\n    #tests.yaw_test_graph()                         # look to presentations for all available tests\n    #tests.drive_torture_test()\n    #return  # uncomment to stop here                # program will stop here, comment out when done\n    #tests.drive_test_rectangle()\n    #return                                         \n    \n\n    #################################################\n    # if you need to power single motor you can \n    # create versions of the spinny motor class\n    #################################################\n    right_spin = spinny('RTSP', port.D, 230,        # name, motor port, max_deg, all required\n            motor_velocity.SPIKE_LARGE_MOTOR,       # max_vel(osity) required  \n                                                    # Optional settings, defaulted as shown\n            accuracy=1,                             # How close to target is good? range is -1,0,1\n            stop_mode=motor.SMART_BRAKE,            # What to do when you stop the motor. \n            close_degrees=50,                       # How close to target do we go slow for accuracy.\n            close_speed=10)                         # What speed to use when close. \n                                                    # using default on all other options. \n\n    left_lift = spinny('LFLT', port.C, 140,        # name, motor port, max_deg, all required\n            motor_velocity.SPIKE_LARGE_MOTOR,    # max_vel(osity) required\n                                                    # Optional settings, defaulted as shown\n            accuracy=10,                            # How close to target is good? range is -1,0,1\n            stop_mode=motor.SMART_BRAKE,            # What to do when you stop the motor.\n            close_degrees=80,                    # How close to target do we go slow for accuracy.\n            close_speed=60)                        # What speed to use when close.\n                                                    # using default on all other options.\n    \n\n\n    # spinny tests                                   # spinny tests - comment out or delete when done.    \n    #front_lift.test([100], loops=1)                # This will rest you arm be prepared to stop.\n    #front_lift.test([ -75, -100, -0], speed=20, loops=1) # This will run throught several positions\n    #return  # uncomment to stop here                # program will stop here, comment out when done\n\n    #################################################\n    # your code goes under here.\n    # these can be movements or functions you create\n    # when ready to use the tests, you comment out \n    # your code. \n    #################################################\n    # these are just the calls, to your customized\n    # functions. They are defined below the main method\n\n    # Code for 1st Mission\n    gyro_drive('s', target=72, speed=40)\n\n    # Doing 1st Mission\n    Drive.spin_far_speed = 66\n\n    gyro_spin_to_angle(320, spin_left=True)\n\n    # Code for 2nd Mission\n\n    move_forward_duration(500, 0.2)\n\n    turn_left(500, 0.3)\n\n    move_forward_duration(-300, 0.3)\n\n    # Doing 2nd Mission\n\n    Drive.spin_far_speed = 33\n\n    gyro_spin_to_angle(75, spin_left=True)\n\n    right_extension(-300, 0.35)\n\n    move_forward_duration(300, 0.35)\n\n    Drive.spin_far_speed = 100\n\n    gyro_spin_to_angle(33, spin_left=True)\n\n    Drive.spin_far_speed = 20\n\n    gyro_spin_to_angle(33, spin_right=True)\n\n    right_extension(300, 0.35)\n    \n    #sleep(2)\n    # in this case we want the arms to move while\n    # we drive. This can save a lot of time.\n    # asunc_op says do not spin the motors youself.\n    #front_lift.run(100,25, async_op = True)             #set front to go up\n    #rear_lift.run(100,10, async_op = True)              #set back to go up\n\n    # Now we call gyro_drive. Because there is a list, \n    # gyro_drive will call the static spinny method \n    # spinny.spin_multi_motors in each loop it will \n    # tell the spinnys to move\n    # Warning: You MUST make sure that the arms are done\n    # before the drive is done. With gyro_drive we are \n    # unable to easily stop the spinnys\n    \n    # imaging using this at the end of your run\n    #front_lift.run(0,80, async_op = True)               # set front are to go down\n    #rear_lift.run(0,80, async_op = True)                # set back are to go down\n    # the spinny class has a static method to move \n    # multiple spinnys, without using gyro drive\n    #spinny.spin_multi_motors([front_lift,rear_lift])    \n\n\n    #gyro_drive('d', 50, -30, spinny_list= [front_lift, rear_lift] )\n\n    exit(0)\n\n    #while True:\n    #    front_lift.run(0,20, async_op = True)\n    #    rear_lift.run(0,20, async_op = True)\n\n    #    if front_lift.result_code != front_lift.RUNNING and \\\n    #    rear_lift.result_code != rear_lift.RUNNING:\n    #        break\n\n\n\n\n    #m1_Attack_the_left()    # Mark and Andrew\n\n    #m2_go_for_the_center()    # Linda and Anne\n\n    #m3_attack_the_left_side() # Jaylin and Sasha\n\n    #m4_the_coup_de_grace()    # not assigned\n    #return\n\n    ################################################################\n    # end of main function. \n    ################################################################\n\n\n\n################################################################\n# put your custom function definitions here\n# create your own functions, then call them above\n# These are examples. remove them is you wish\n###############################################################\n\n#Forward function\ndef move_forward_duration(speed, duration):\n    #Starts motors\n    motor.run(port.A, -speed)\n    motor.run(port.E, speed)\n\n    #Waits for duration time\n    sleep(duration)\n\n    #Stops motors\n    motor.stop(port.A)\n    motor.stop(port.E)\n\ndef turn_right(speed, duration):\n    motor.run(port.A, -speed)\n    sleep(duration)\n    motor.stop(port.A)\n\ndef turn_left(speed, duration):\n    motor.run(port.E, speed)\n    sleep(duration)\n    motor.stop(port.E)\n\ndef left_extention(speed, duration):\n    motor.run(port.C, speed)\n    sleep(duration)\n    motor.stop(port.C)\n\ndef right_extension(speed, duration):\n    motor.run(port.D, -speed)\n    sleep(duration)\n    motor.stop(port.D)\n\ndef backwards_right(speed, duration):\n    motor.run(port.E, -speed)\n    sleep(duration)\n    motor.stop(port.E)\n\ndef backwards_left(speed, duration):\n    motor.run(port.A, -speed)\n\n    sleep(duration)\n    motor.stop(port.A)\n\ndef move_forward(speed, distance):\n    #Make _distance the distance the sensor picks up from port B\n    _distance = distance_sensor.distance(port.B)\n    distance = distance * 10\n    #Start a loop to go forward\n    #While the distance from sensor is less than the distance we want - 30\n    print(\"(pre) Distance from sensoe is \", _distance)\n    print(\"(pre) Target Distance is \", distance)\n    while _distance < (distance-30) :\n        #Start motor to go forward\n        motor.run(port.A, -speed)\n        motor.run(port.E, speed)\n        #Wait 0.001 seconds before checking distance\n        sleep(0.001)\n        #Update distance\n        _distance = distance_sensor.distance(port.B)\n        #Show current distance\n        print(\"Distance is \", _distance)\n    #Once the distance is correct, stop the motor\n    motor.stop(port.A)\n    motor.stop(port.E)\n\n\ndef m1_Attack_the_left():\n    #global Drive, front_lift\n    front_lift.run(50,100, async_op=True)\n    gyro_drive('d', 70, 80, 0)    \n    gyro_spin_to_angle(45)\n    front_lift.run(23,100)      # lift to 50% at speed 10%\n    sleep(1)\n    gyro_spin_to_angle(-13)     # hit the rocks and flippy garden\n    front_lift.run(0,90)        # lift to 50% at speed 10%\n    gyro_spin_to_angle(-55)     # hit objects\n\n    gyro_drive('d', 10, 50)     # move forward to avoid object on the left\n    gyro_spin_to_angle(-90)\n    \n    gyro_drive('d', 73, 90)     # drive to mining tower\n    gyro_spin_to_angle(-55)     # turn to tower\n    front_lift.run(85,10)       # slowly lift the arm\n    sleep(2)\n    front_lift.run(0,100)       # drop lift down\n    gyro_drive('d', 30,  80, -90)\n    gyro_drive('d', 50, 100, -135)\n\n\n\n\ndef m2_go_for_the_center():\n    # Linda and Anne are working on this.\n    pass                                     # Google: python pass\n\ndef m3_attack_the_left_side():\n    # Jaylin and Sasha are working on this. \n    pass\n\ndef m4_the_coup_de_grace():\n    # not assigned to anyone. \n    pass\n\n\n\n#################################################\n# Gyro Drive classes, settings and functions\n# Modify but do not remove\n#################################################\n\nclass gyro_drive_settings(): \n\n    \"\"\"\n    This is a class that supports various tests \n    to dial in your robot. These are a great \n    teaching tool because the students can see\n    what is happening. Then by walking the code\n    the can see how it is done. \n\n    Settigns from my testing\n    wheel_diameter    = 8.85    # big 88 mm wheels,\n    wheel_diameter    = 5.57    # small 56 mm wheels\n\n    Why is 8.80 not working and you had to fuge it?\n    This is a toy. After testing alot, these values\n    worked on my robots. You will need to dial in\n    yours. \n\n    \"\"\"\n\n    ################################################\n    # class initator do not touch\n    ################################################\n    # Warning: This code is executed when we\n    # create the class. DO NOT CHANGE ANY OF\n    # the variables below once program starts.\n    ################################################\n    def __init__(self,\n        wheel_diameter,\n        motor_port_left,                                # use port. definitions\n        motor_port_right,\n        measure_motor_port,\n        motor_max_velocity):\n\n        self.wheel_diameter = wheel_diameter\n        self.motor_port_left = motor_port_left\n        self.motor_port_right = motor_port_right\n        self.measure_motor_port = measure_motor_port\n        self.motor_max_velocity = motor_max_velocity\n\n        # distance calcs                                # do not remove these\n        Pi                = 3.14159                     # Thank you Archimedes of Syracuse for Ï€\n        self.wheel_circumference = \\\n            Pi * float(self.wheel_diameter)             # all them Greeks knew about it\n\n        self.distance_per_degree = \\\n            self.wheel_circumference / 360              # how far do we go in 1 degree of movement\n                                                        # think of it a distance around a pizza slice\n                                                        # if cut into 360 slices.\n\n                                                # Google: python ticks_ms   \n    program_started_sec = ticks_ms()/1000       # ticks_ms() capture the start moment in milliseconds\n                                                # /100       divide by 1000 to get seconds decimal. \n                                                # ticks_ms starts from 0 when you turn on the hub. \n                                                # If you leave the robot on it will rollover to 0 \n                                                # after 298 days. Try not to leave you hub on \n                                                # for that long. :) \n    ###########################################\n    # All the code below can be changed after \n    # the class is created using the form\n    # Drive.blabla = blabla\n    # Make sure you do this where all can see \n    # it in case they are relying on this value\n    ###########################################\n\n    # one motor must run in reverse             # we multiply velocity * -1 to invert that motor\n    motor_left_direction = -1                   # normally flipped (-1)\n    motor_right_direction = 1                   # normally runs forward (1).\n\n    motor_pair_id = motor_pair.PAIR_3           # there are 3 possible motor_pairs \n                                                # we are using PAIR_3. This allows\n                                                # us to assign the lef a right drive\n                                                # motors to a motor_pair. Then the\n                                                # motors are started/stopped together. \n    \n    distance_sensor_port = port.B                  # must be set when using distance sensor\n    distance_sensor_accuracy = .3               # how close to target is good? +/- this\n\n    color_sensor_port    = -1                   # must be set when using color sensor\n\n    # test these spin settings to fit your robot.\n    spin_far_range      = 25                    # degrees from target where we spin fast\n    spin_far_speed      = 20                    # when range is > spin_far_range, spin faster\n    spin_near_speed     = 5                     # when range is <= spin_far_range near, spin slow\n\n                                                # stop at within spin_accuracy \n    spin_accuracy       = 2.0                   # we are on target+/- this accuracy\n                                                # the robot has momentum and robot can't stop\n                                                # on a dime so we make accuracy wide.\n                                                # This gives the code time to stop the spin\n                                                # close to the angle we want.\n                                                # Students learn about tradeoffs.\n\n    # speed defaults - experimant on your design. \n    # you do not need to use these \n    # just here as suggestions.                                                             \n    default_speed        = 60                    # you set to what you want. \n                                                 # use Drive.default_speed in functions to use this\n    default_rev_speed  = default_speed           # determine this by testing.                       \n                                                        \n    min_speed            = 10                    # minimum drive speed so we don't get stuck\n                                                 # gyro_drive asks for speed. As we get close\n                                                 # the speed man be very low. This will be the \n                                                 # minimum. Hey, robot has to move, right!!!\n                                                 # speed is 0 to 100 percent of max velocity.\n    \n    settle_time        = .30                     # once we reach the target, pause to let the robot settle\n                                                 # a heavier robot may need a little more time\n\n    # gyro yaw settings\n    use_yaw_360         = True                   # if True get_yaw will allow you to use angles from\n                                                 # 0 to +/- 540. However, you can cross +/- 180 and +/- 360.\n                                                 # you need to be careful around +/- 540\n\n\n    yaw_adjust           =  .5                   # A multiplier to adjust your motors to move back to the\n                                                 # gyro heading when we are using the gyro. \n                                                 #  .5 one half of correction, gentle nudge works best\n                                                 # 1.0 is no additional adjustment, correction is applied as is \n                                                 # heavy robots may need more to move back to gyro line.  \n                                                 # 2.0 will give you 2 times adjustment power\n                                                 # 3.0 will give you 3 times adjustment power\n                                                 # Warning: Too munch and you get overcorrection\n                                                 # Google: overcorrection\n\n    # acceleration parameters \n    accel_ramp_up_dist_pct  = .18               # this is multipled by speed to figure out\n                                                # how large to make the ramp up and down distance. \n\n    accel_min_ramp_up_dist  = 2.0               # minimum ramp up distance. 2.0 cm is 4/5 of an inch.\n\n\n\n    use_linegraph       = False                 # set to True to see linegraph of gyro drive\n\n    result_code = results.CODE_RESET            # global var Drive.result_code to track function results. \n                                                # mostly used the overrides like timeout and waypoint. \n                                                # shows up as yellow in plots\n\n    last_distance_cm = 0                        # how far Gyro_drive went the last time out in cm\n                                                # updated every time gyro_drive finishes moving\n                                            \n    pass_count = 0                              # how many pass through the code\n    gyro_drive_passes = 0\n\n    logging_level = log_level.ALL               # what log level will we print\n\n    log_source_filter = \"\"                      # no display filters, display all\n    #log_source_filter = \"GETY\"                 # display only these logs\n\n\n\n#################################################\n# Gyro Drive functions\n# Modify but do not remove\n#################################################\n\n\ndef gyro_drive( drive_by,                            # d = distance, t = time (sec), s = sonar\n                target,                                # distance or time\n                speed,                                # % of power +/- 10 to 100\n                request_angle = None,                # angle to follow +/- 540. See get_yaw\n                                                        # if None, gyro correction and turn_first are ignored\n\n                timeout=None,                        # time sec to stop is not completed.\n                waypoint = None,                        # color to look for. Will stop at the color.\n                spin_left=False,                        # set True to spin left avoiding objects on the right\n                spin_right=False,\n                spinny_list = []):                    # set True to spin right avoiding objects on the left\n\n    global Drive                                        # all the variable in Drive class available here.\n                                                        # defined at the top of main\n\n    current_reading = 0                                # gyro drive current sensor reading\n                                                        # do not manually change\n                                                        # type d, distance in centimeters\n                                                        # type t, elapsed time\n                                                        # type s, sonar distance in centimeters\n    Drive.logging_level = log_level.ALL\n\n    yaw = actual_yaw = 0                                # set here so no errors down below\n                                                        # yes this is ok\n    if Drive.use_linegraph == True:\n        gyro_drive_plot(speed, target, request_angle,\n                result_code = Drive.result_code )\n\n    if request_angle is not None:                    # In None gyro nav is off.\n        gyro_spin_to_angle(request_angle,            # point us in the new direction first before driving\n                            spin_left,                # if true force spin left, up to operator\n                            spin_right)                # if true force spin right, up to operator\n\n        yaw, actual_yaw = get_yaw(request_angle)        # get yaw returns 2 items always\n\n\n\n\n    ''' Explain: Drive_by is a string\n        Strings are a list of characters. Google: python list\n        We hope drive-by will contain d for distance, t for time,\n        or s for distance sensor\n        drive_by[0] Take the first character in string drive_by\n        [0].lower() converts to lower case character for testing\n    '''\n    # clean up this just in case\n    drive_by = drive_by.strip()                            # remove all spaces around it. Google: python strip\n    if len(drive_by) == 0: drive_by = 'd'                # if now blank, force to d for distance\n    drive_by = drive_by[0].lower()                        # take first character [0] and force to lower\n\n    motor.reset_relative_position(Drive.measure_motor_port,0) # before we drive, reset the measure motor start point\n    result_code = results.CODE_RESET                        # Reset here becasue turn_to_angle will set it.\n    Drive.last_distance_cm = 0                            # this will be how far we traveled when gyro_drive finishes.\n\n    # Make sure we can at least move                        # too low, no movement. Adjust for you robot weight\n    if abs(speed) < Drive.min_speed:                        # are we below minimum speed in either direction\n        if speed < 0:\n            speed = Drive.min_speed * -1                    # reverse the drive\n        else:\n            speed = Drive.min_speed                        # leave it forward\n\n    calc_speed = 0                                        # declared here so we do not have hightights below\n    color_sensor_reading = None                            # define here so we have no highlighte below\n\n    function_started_sec = get_hub_sec()                    # local function timer vs Drive.program_started_sec\n\n\n    passes = 0\n    while True:                                            # loop forever, we need to break out or return out\n        passes += 1\n\n        local_elapsed_sec = \\\n            get_elapsed_sec(function_started_sec)        # subtracts current seconds from when function started\n\n        if timeout is not None and \\\n                        local_elapsed_sec > timeout:        # is there a timeout and did we expire it\n            motor_pair.stop(Drive.motor_pair_id,\n                                stop=motor.SMART_BRAKE)    # stop the robot by locking motors, no roll\n            Drive.result_code = results.TIMED_OUT        # set the Drive.result_code\n\n            if Drive.use_linegraph == True:\n                gyro_drive_plot(speed, target,\n                        result_code = Drive.result_code,\n                        color_reading = color_sensor_reading,\n                        last_step = True)\n\n            sleep(Drive.settle_time)                        # allow robot to settle, greatly improves accuracy\n\n            # remeber how many cm's we traveled\n            Drive.last_distance_cm = \\\n                int(abs(motor.relative_position(Drive.measure_motor_port)\n                        * Drive.distance_per_degree))        # calculate the distance.\n\n            log(log_level.END,\n                'GYDR', \" | Done\",\n                ' | drive_by: ', \" option: timeout\",\n                ' | result_code: ', get_result_code_text(),\n                ' | passes: ', passes)\n\n            return\n\n        # are we looking for a waypoint color?\n        if waypoint is not None:                            # this is an optional parameter,\n                                                            # if not None we do something\n            color_sensor_reading = \\\n                color_sensor.color(Drive.color_sensor_port) # this may be highlighted if no color sensor\n                                                            # port is defined.That is ok.\n\n            if color_sensor_reading == waypoint:            # did the color sensor see the color we want\n                motor_pair.stop(Drive.motor_pair_id,\n                                    stop=motor.SMART_BRAKE)\n\n                Drive.result_code = results.WAYPOINT_DETECTED# set the Drive.result_code\n\n                if Drive.use_linegraph == True:\n                    gyro_drive_plot(calc_speed, target,\n                            result_code = Drive.result_code,\n                            color_reading = color_sensor_reading,\n                            last_step = True)\n\n                sleep(Drive.settle_time)                    # allow robot to settle, greatly improves accuracy\n\n                Drive.last_distance_cm = \\\n                    int(abs(motor.relative_position(Drive.measure_motor_port)\n                            * Drive.distance_per_degree))\n\n                log(log_level.END,\n                    'GYDR', \" | Done\",\n                    ' | drive_by: ', \" option: waypoint color\",\n                    ' | result_code: ', get_result_code_text(),\n                    ' | passes: ', passes)\n\n                return                                    # Get out of this function, Google: python return\n        else:\n            color_sensor_reading = None\n\n        ######################################################\n        # Begin if / else ladder or decision tree\n        ######################################################\n        if drive_by == 'd':                                # Is this drive by distance?\n\n            current_reading = \\\n                abs(motor.relative_position(Drive.measure_motor_port)\n                        * Drive.distance_per_degree)        # calculate the distance.\n\n            log(log_level.STEP,\n                    'GYDR', \" | Done\",\n                    ' | drive_by: ', drive_by,\n                    ' | result_code: ',\n                        get_result_code_text(),\n                    ' | target distance: ',\n                        current_reading,\n                    ' | passes: ', passes)\n\n            if current_reading >= abs(target):\n                motor_pair.stop(Drive.motor_pair_id,\n                                    stop=motor.SMART_BRAKE) # drives will stop together.\n                Drive.result_code = results.TARGET_REACHED# set the Drive.result_code\n\n                if Drive.use_linegraph == True:\n                    gyro_drive_plot(calc_speed,            # plot the final results\n                        current_reading,\n                        target,\n                        result_code = Drive.result_code,\n                        color_reading = color_sensor_reading)\n\n\n                sleep(Drive.settle_time)                    # allow robot to settle, greatly improves accuracy\n\n                Drive.last_distance_cm = \\\n                    int(abs(motor.relative_position(Drive.measure_motor_port)\n                            * Drive.distance_per_degree))\n\n\n                log(log_level.END,\n                    'GYDR', \" | Done\",\n                    ' | drive_by: ', drive_by,\n                    ' | result_code: ',\n                        get_result_code_text(),\n                    ' | target distance: ',\n                        current_reading,\n                    ' | passes: ', passes)\n\n\n                return                                    # Get out of the function, Google: python return\n\n            calc_speed = acceleration(target,\n                                    speed,\n                                    current_reading,\n                                    Drive.accel_ramp_up_dist_pct,\n                                    Drive.min_speed)        # pass min_speed from Drive settings\n\n\n        elif drive_by == 't':                            # processign a travel over time\n            calc_speed = speed\n\n\n            log(log_level.STEP,\n                'GYDR', \" | Done\",\n                ' | drive_by: ', drive_by,\n                ' | result_code: ',\n                    get_result_code_text(),\n                ' | elapsed sec: ',\n                    local_elapsed_sec,\n                ' | passes: ', passes)\n\n\n            if local_elapsed_sec >= target:                # are we sat the requested time>\n                motor_pair.stop(Drive.motor_pair_id,\n                                    stop=motor.SMART_BRAKE)\n                Drive.result_code = results.TARGET_REACHED\n\n                if Drive.use_linegraph == True:\n                    gyro_drive_plot(calc_speed,            # plot the final results\n                        local_elapsed_sec,\n                        target,\n                        result_code = Drive.result_code,\n                        color_reading = color_sensor_reading)\n\n\n                sleep(Drive.settle_time)                    # allow robot to settle, greatly improves accuracy\n\n                Drive.last_distance_cm = \\\n                    int(abs(motor.relative_position(Drive.measure_motor_port)\n                            * Drive.distance_per_degree))\n\n                log(log_level.END,\n                    'GYDR', \" | Done\",\n                    ' | drive_by: ', drive_by,\n                    ' | result_code: ',\n                        get_result_code_text(),\n                    ' | elapsed sec: ',\n                        local_elapsed_sec,\n                    ' | passes: ', passes)\n                return                                    # Get out of function, Google: python return\n\n\n        elif drive_by == 's':\n            current_reading = \\\n                distance_sensor.distance(\n                        Drive.distance_sensor_port) * .1    # distance comes in as integer milimeters\n                                                            # mult by .1 changes it to float centimeters\n            closing_speed = speed\n\n            log(log_level.STEP,\n                'GYDR', \" | Done\",\n                ' | drive_by: ', drive_by,\n                ' | result_code: ',\n                    get_result_code_text(),\n                ' | current distance: ',\n                    current_reading,\n                ' | target distance: ',\n                    target,\n                ' | passes: ', passes)\n\n            if current_reading >= \\\n                target - Drive.distance_sensor_accuracy and \\\n                current_reading <= \\\n                target + Drive.distance_sensor_accuracy:    # are we close to the target distance\n\n                motor_pair.stop(Drive.motor_pair_id,\n                                stop=motor.SMART_BRAKE)\n                Drive.result_code = results.TARGET_REACHED# set the Drive.result_code\n\n                if Drive.use_linegraph == True:\n                    gyro_drive_plot(closing_speed,        # plot the final results\n                        current_reading,\n                        target,\n                        result_code = Drive.result_code,\n                        color_reading = color_sensor_reading)\n\n                sleep(Drive.settle_time)                    # allow robot to settle to improve accuracy\n\n                Drive.last_distance_cm = \\\n                    int(abs(motor.relative_position(Drive.measure_motor_port)\n                            * Drive.distance_per_degree))\n\n                log(log_level.END,\n                    'GYDR', \" | Done\",\n                    ' | drive_by: ', drive_by,\n                    ' | result_code: ',\n                        get_result_code_text(),\n                    ' | current distance: ',\n                        current_reading,\n                    ' | target distance: ',\n                        target,\n                    ' | passes: ', passes)\n                return                                    # We reached the target! Google: python return\n\n            elif current_reading < target:                # too close back up\n                calc_speed = closing_speed\n            elif current_reading > target:                # go closer\n                calc_speed = -closing_speed\n\n        else:\n            raise( Exception( \"gyro_drive: tdrive by type not d, t, or s!'\") )\n\n        # Endif / else ladder of decisions\n\n        # now drive based upon what was set above.\n        # this return a 2 value tuple. You can catch them a a tuple\n        # or as we did there as the 2 seperate values.\n        left_velocity, right_velocity = \\\n            calc_drive_velocities( calc_speed, request_angle,# returns velocities as a tuple!!!! Has 2 values\n                            Drive.motor_max_velocity,\n                            Drive.yaw_adjust )\n\n        motor_pair.move_tank(Drive.motor_pair_id,            # forces motors to start together.\n                            left_velocity,                    # left\n                            right_velocity)                    # right\n\n        if Drive.use_linegraph:\n            gyro_drive_plot(calc_speed,                        # plot where we are\n                        current_reading,\n                        target,\n                        result_code = Drive.result_code,\n                        color_reading = color_sensor_reading)\n\n        if len(spinny_list) > 0:\n            spinny.spin_multi_motors(spinny_list, async_op=True)\n\n\ndef gyro_drive_plot(speed, \n                    current = None,                             # if None, do not plot\n                    target = None, \n                    result_code = None,\n                    color_reading = None, \n                    last_step = None):\n    \n    global Drive                                                # give us access to the settings\n\n    elapsed = get_elapsed_sec( Drive.program_started_sec)       # calc elapsed time from program start\n\n    linegraph.plot(color.RED,    elapsed,  speed)          \n    yaw, actual_yaw = get_yaw()\n    linegraph.plot(color.PURPLE, elapsed,  yaw)                 # yaw reading\n    linegraph.plot(color.MAGENTA, elapsed, actual_yaw)          \n    \n    if current is not None: \n        linegraph.plot(color.GREEN, elapsed, current)           # current position, reading whaever\n\n    if target is not None: \n        linegraph.plot(color.BLUE,  elapsed, target)            # were are we going?\n\n    if color_reading is not None:                               # color sensor reading\n        linegraph.plot(color.BLACK, elapsed, color_reading)\n\n    if result_code is not None:\n        linegraph.plot(color.YELLOW, elapsed, result_code )\n\n    if last_step is not None:\n        linegraph.plot(color.ORANGE, elapsed, 3)                # mark the end of a movement\n\n\ndef get_yaw(request_angle = 0.0, raw=False ):\n\n    global Drive\n\n    \"\"\"\n    Returns the yaw from the motion hub sensor. \n    We cook it to spoof (trick) it to work through \n    +/-180 degrees and +/-360 degrees.\n\n    This is done by looking at the request_angle passed. \n    The spoofing will make so the yaw will support the \n    passing beyond 180 degrees. \n\n    Parameters:\n    request_angle (float): Angle you are trying to turn to. \n\n    raw :        Boolean (True/False) to use the the uncooked\n                 raw yaw value. Otherwise we use round(yaw).\n                 This helps when you have a drfiting gyro value.\n                 We may not need this as we have figured out\n                 How to correct that.\n\n    Example:     yaw, actual_yaw = get_yaw(request_angle)\n\n\n\n    Returns: WARNING: This always return 2 values called \n            a tuple. The 2 values are the spoofed yaw \n            and the actual_yaw from the motion sensor.\n\n    \"\"\"\n\n    log(log_level.START, 'GETY' ,\n            ' | req_angle: ', request_angle,\n            ' | raw: ', raw )\n\n    robot_angles = motion_sensor.tilt_angles()              # this returns a tuple. Google: python tuple\n                                                            # The tuple robot_angles has all our angles.\n\n    if raw == True:\n        yaw = (robot_angles[0]/10)                          # raw no rounding\n    else:    \n        yaw =round((robot_angles[0]/10))                    # [0] is the first item in the tuple. Yaw is an \n                                                            # int of decidegress. We divide by 10 to get degrees. \n                                                            # This is now a float or decimal. We round it to \n                                                            # improve movement.\n\n                                                            # In Spike Python left yaw is positive, right negative\n    yaw = yaw * -1                                          # We want to make it the same as Blocks, so we flip it \n                                                            # now left is -, and right is +.\n\n    request_angle = int(request_angle)                      # MicroPython likes integers. \n\n    actual_yaw = yaw                                        # save the actual yaw as actual_yaw\n\n    if Drive.use_yaw_360 == False:                          # Use +/- 180 degree compass\n\n        log(log_level.END, 'GETY' ,\n            ' | req_angle: ', request_angle,\n            ' | raw: ', raw,\n            ' | actual_yaw: ', actual_yaw,\n            ' | yaw: ', yaw)\n\n    else:                                               # Use +/- 360 degree compass\n\n        op = 0                                          # tell us what operation was used\n\n        # spinning left, negative direction\n        if request_angle < -135:                        # -135 allows clean movement over -180 degrees.\n\n            op = 1                                      # this takes us from -0 to -180  \n                                                        # just show the yaw no change to yaw\n\n            if request_angle < -315 and \\\n                yaw <= 0 and yaw < 180:                 # ensure clean past -360 to -540\n                    yaw = -360 + yaw                    # yaw between 0 and 180\n                    op = 13                            \n\n            elif yaw < -180:                            # not sure this does anything\n                op = 11\n                yaw = yaw + 360\n\n            elif yaw > 0 and yaw < 180:                 # support -180 passing  to -360\n                op = 12                                 # now yaw is 179 to 1\n                yaw = (360 - yaw) * -1                  # yaw < 180  360-179 = 181 * -1 = -181\n\n        # spinning right, positive direction\n        elif request_angle > 135:                       # all below happens if we are 135 or higher\n            op = 2 # this takes us from 135 to 180      # 135 allows clean movement over 180 degrees. \n\n            if request_angle > 315 and \\\n                yaw >= 0 and yaw <= 180:                # override to 540 when we req_angle > 315\n                                                        # set up to spin to +540 degrees 180+360=540\n                yaw = yaw + 360                         # we start at 360 and add yaw up to 180\n                op = 23                                 #  0 + 360 = 360,1 + 360 = 361,\n                                                        # 90 + 360 = 450, 180 + 360 = 539\n                                                        # range up to 540\n\n            elif yaw > 180:                             # not sure this does anything        \n                op = 21                                 # yaw cannot be > 180\n                yaw = yaw - 360\n\n            elif yaw < 0 and yaw >= -180:               # Are we between -179 and -1\n                op = 22                                \n                yaw = (yaw + 360)                       # add yaw to 360, we extend 180 to 181, 182...\n                                                        # -179 + 360 = 181, -178 + 360 = 182\n                                                        # range is up to 360\n\n\n\n        if op == 21 or op == 11:\n            log(log_level.END, 'GETY' , \n                ' | req_angle: ', request_angle,\n                ' | raw: ', raw ,\n                ' | op:', op,\n                ' | hub yaw: ', actual_yaw ,                 \n                ' | calc yaw: ', yaw )\n\n\n    return yaw, actual_yaw                              # return both yaws. User chooses\n\n\n\ndef calc_drive_velocities( speed, \n                         request_angle,                 # angle can be None. This turns off gyro navigation\n                         max_velocity, \n                         yaw_adjust = 1.0):\n\n    ''' \n    We created this so you can use it in your own drive functions.\n    This is desiogned to take a max velocity and a speed% along with\n    the requested angle and return the gyro corrected velocities. \n\n    if request_angle is None then the velocities will be the same \n    reflecting no gyro correction. \n\n    parameters:\n        speed - your motor speed\n        request_angle - what angle you want to steer. None turns off gyro nav.\n        max_velocity - the maximum velosity of the motor as define in spike\n                    for small, medium and large LEGO motors.\n        yaw_adjust - this value is used to give more for the the correction of yaw.\n                    it is defaulted to 1. If you do not put in the parameter it wil be 1.\n\n    In Blocks gyro.yaw comes in as - when turning left and + when turning right\n    In Python gyro.yaw comes in as + when turning left and - when turning right\n        Note: We adjusted our python function get_yaw() to force yaw to be flipped to \n                match what happens in Blocks so, - is left, + is right. \n    '''\n\n    if request_angle is None:                                       # no navigation requested\n        yaw_correction = 0                                          \n        yaw = 0                                           \n    else: #request_angle is not None                     \n        yaw, actual_yaw = get_yaw(request_angle)                    # always capture both        \n\n        yaw_correction = (request_angle - yaw)                      # this is how much we are off + right, - left\n\n    left_speed  = speed + yaw_correction                            # apply the correction to the speed\n    right_speed = speed - yaw_correction                            # opposite to bring you back \n\n    left_velocity =  int(calc_pct_value(max_velocity,  left_speed)) # calculate the velocity from the speed\n    right_velocity = int(calc_pct_value(max_velocity,  right_speed))\n\n    log(log_level.END, \"CDVL\",\n            \" | req_angle: \", request_angle,\n            ' | speed: ', speed,\n            ' | yaw: ', yaw, \n            ' | corection: ', yaw_correction,\n            ' | speeds (l/r): ', left_speed, '/', right_speed )\n\n    return left_velocity, right_velocity                            # return the 2 velocities as integers\n                                                                    # returning 2 items creates a tuple\n                                                                    # Google: what is a python tuple\n \n\n\ndef acceleration( tot_distance, speed, curr_distance, \n            accel_ramp_up_dist_pct = .10, \n            accel_min_speed = 5, \n            reverse_ramp_up_speed = 40):\n\n    \"\"\"\n    Calculates the acceleration, steady state and \n    decelleration of your robot. It is callled by \n    others passing the appropriate parameters.\n\n    Parameters:\n    tot_distance (int):  Total distance you want to go\n\n    speed (int):         Percent of speed +/- 0 to 100 \n\n    curr_distance (int): How far you have gone in distacne so far\n\n    accel_ramp_up_dist_pct (float): multiplied against speed \n                        to calculate the ramp up distance. \n                        defaults to .10\n\n    accel_min_speed (int): Minimum speed to be sure we \n                        get to the end\n\n    Returns:\n    Calculated speed at this point over the distance\n\n    \"\"\"\n\n    if accel_ramp_up_dist_pct == 0:                                 # turn off acceleration\n        return speed\n\n    ramp_up_dist = accel_ramp_up_dist_pct * abs(speed)              # This produces a percent we use \n    if ramp_up_dist < Drive.accel_min_ramp_up_dist:                 # to calc ramp up distance\n        ramp_up_dist = Drive.accel_min_ramp_up_dist                 # 2 cm default. Less than 1 inch\n                                                                    # distance that will be the ramp up \n                                                                    # distance?  Why?\n\n    # Capture the direction\n    if speed < 0: \n        direction = -1                                              # reverse, negitive direction\n    else:\n        direction = 1                                               # forward, positive direction\n\n    # we have direction so all calculations \n    # are now done using abs. We are positive now\n    curr_distance = abs(curr_distance)                              # Google: abs or absolute value. \n    speed = abs(speed)\n\n    if speed < accel_min_speed:   \n        speed = accel_min_speed                                     # make sure we can move\n\n    # calculate the ramp up and down distances\n    ramp_pct_traveled = 0                                           # starting from the beginning\n\n    #ramp_up_dist = tot_distance * accel_ramp_up_dist_pct            # ramp_up distance is how far \n                                                                    # will we ramp up the speed\n\n    ramp_down_dist = ramp_up_dist * 2                               # ramp down twice as big for slowing down\n    ramp_down_start_dist = tot_distance - ramp_down_dist            # where does ramp down start?\n\n    if abs(speed) < abs(reverse_ramp_up_speed):                     # if reversing fast, make ramp up tripple in size\n        ramp_up_dist *= 3                                           # this may help prevent wheel slip, test!!!!!\n\n    log(log_level.START, 'ACEL',\n                        \" | speed:\" + str(speed),\n                        \" | curr_dist:\" + str(curr_distance),\n                        \" | ramp_up:\" + str(ramp_up_dist),\n                        \" | ramp_dn:\" + str(ramp_down_start_dist) )\n\n\n\n    ################################################################\n    # Now we need to decide what to do. \n    # what part of the run are we in. \n    # This is called an if / else ladder. \n    ################################################################\n    # are we passed the total distance?\n    if curr_distance >= tot_distance:                               # if done return 0 speed.\n        log(log_level.END, 'ACEL',\n                \" | Done \",\n                \" | curr_distance: \" , curr_distance,\n                \" | tot_distance:\" , tot_distance)\n\n        return 0                                                    # we are where we want to be. \n                                                                    # length or distance is never negative. \n\n    # Are we in ramp down mode?                                     # down mode takes priority, why?\n    elif curr_distance > ramp_down_start_dist:                      # Is the distance within the ramp_down?\n        curr_ramp_dist = curr_distance - ramp_down_start_dist       # get the distance in ramp_down area only, not total\n        ramp_pct_traveled = curr_ramp_dist / ramp_down_dist         # get the percentage in the ramp_down distance\n\n        # unlike ramp up, we are in ramp down, we slow down         # nice chance for thought experiment!!!\n        pct_slowing = (1.0 - ramp_pct_traveled)                     # this will go from 1.0 to .00, slowing down\n                                                                    # .10 is now .90, .25 is now .75\n        calc_speed = speed * pct_slowing                            # Calculate the new slowing speed\n\n        if calc_speed <= accel_min_speed:                           # check that we are minimum speed\n            calc_speed = accel_min_speed                            # if not we may not move at very slow speeds\n\n        calc_speed *= direction\n\n        log(log_level.END, \n                'ACEL',\n                \" | Ramp Down \",\n                \" | direction: \" , direction,\n                \" | calc_speed:\" , calc_speed,\n                \" | curr_ramp_pct_trav:\", ramp_pct_traveled ,\n                \" | pct_slowing:\" , pct_slowing)\n\n\n        return calc_speed                                          # convert back to the direction\n\n    # Are we in ramp up mode?\n    elif curr_distance < ramp_up_dist:                              # Is the distance within the ramp_up?\n        ramp_pct_traveled = curr_distance / ramp_up_dist            # get the percentage of the ramp up distance\n\n        calc_speed = speed * ramp_pct_traveled                      # calculate the speed within the ramp up distance\n                                                                    # we are speeding up, pct .0 to 1.0\n\n        if calc_speed <= accel_min_speed:                           # check that we are at minimum speed\n            calc_speed = accel_min_speed                            # if not, we may not move at very slow speeds\n\n        calc_speed *= direction\n\n        log(log_level.END, 'ACEL',\n            \" | Ramp Down \",\n            \" | direction: \" , direction,\n            \" | calc_speed:\" , calc_speed,\n            \" | curr_ramp_pct_trav:\" , \n                ramp_pct_traveled )\n\n\n\n        return calc_speed\n\n    # are we in steady state mode?                                                                                       \n    elif curr_distance >= ramp_up_dist and \\\n                    curr_distance <= ramp_down_start_dist:\n\n        calc_speed = speed * direction\n\n        log(log_level.END,\n            'ACEL',\n            \" | Steady State \",\n            \" | direction: \" , direction,\n            \" | calc_speed:\" , calc_speed,\n            \" | curr_distance:\", curr_distance )\n\n        return calc_speed\n\n    else:                                                           # in case something is broken, tell us!!!\n        print(\"except, curr_dist:\" + str(curr_distance) \n                        + \", up_d:\" + str(ramp_up_dist) \n                        + \", dn_d:\" + str(ramp_down_start_dist))\n\n        raise(Exception(\"acceleration: no ramp calculated!!!!\"))\n\n\n        \ndef get_hub_sec():  \n    ''' \n    The function ticks_ms is imported above from the python time module\n    it returns miliseconds since the robot was turned on. \n    It rolls over in 200+ days so we are good. \n\n    Google: micropython ticks_ms\n    Google: What are milliseconds?\n    '''\n    ms = ticks_ms()                                                 #capture as milliseconds. It is an integer, no decimal\n\n    ''' \n    Google: What is a python integer\n    Google: What is a python float or floating point number\n    Google: python float function\n    convert and return as a float \n    now representing seconds, with decimals, since the robot started.\n    '''\n    return float(ms)/1000                                           # convert to a float and divide by 1000\n                                                                    # now we can do normal math on it. \n                                                                    # return a float in seconds. \n\ndef get_elapsed_sec(start_seconds):\n    ''' \n    Returns the total elpased time from a passed start time.\n\n    parameters:\n        start_seconds - when caller started timing from. \n                        Users mus captru a start point.\n                        Example: start_point = get_hub_sec()\n\n    This allows you to determine elapsed time from a function or\n    from when the program started. It depends on what \n    start_seconds you pass. \n    '''\n\n    return get_hub_sec() - start_seconds                             \n\n\ndef calc_pct_value(max_value, range_value):\n\n    '''\n    calc_pct_value(max_value, range_value):\n        This converts a range +/- 100 into a value you want from a \n        max value for that device. \n\n        Example: Convert the speed to whatever velocity system you are using.\n        In Spike we have 3 different motors and each have a different max\n        velocity. Spike Python tools native velocity is degrees per second.\n\n        That is not very easy for a carbon based unit (middle schooler) to grasp. \n        Here you can provide speed as range_value which is simply \n        percent range of +/- 100. It is very simple to understand and \n        matches what block uses.\n\n        A speed of 25 becomes .25, 50 becomes .5, 100 becomes 1.0\n        Then we multiply max_velocity by speed to get requested velocity. \n        Easy peasy. Very technical term.\n    '''\n\n    pct_value = range_value *.01                                # convert int range_value to float pct_value\n                                                                # now a decimal. 50 becomes .50 or 1/2 \n\n    calc_value = max_value * pct_value                          # multiply max_value by pct_value\n\n    return( calc_value)                                         # return calc_value\n                                                                # return a float for better precision\n                                                                # if max is 1000, 1000 * .50 = 500  (1/2)\n                                                                # receiver can convert to int if they need it. \n\n\ndef gyro_spin_to_angle(request_angle, spin_left=False, spin_right=False):   \n\n    \"\"\"\n    gyro_spin_to_angle(request_angle, spin_left=False, spin_right=False):\n        Spins the robot to the requested angle.\n        It can be called by itself or from \n        gyro_drive. We say spin becasue the robot\n        will normally spin on the center of the robot, \n        over the wheels. \n\n        If it completes normally, it will set \n        Drive.result_code to results.TARGET_REACHED\n\n        Parameters:\n        request_angle (float): The angle you want \n            degrees +/-360. We will calc actual_yaw from it. \n        spin_left: If True forces robot to spin left, default False\n        spin_right: If True forces robot to spin right default False\n\n        Returns:\n        Nothing\n\n    \"\"\"         \n\n    global Drive\n\n    Drive.result_code = results.CODE_RESET\n    speed = 0                                               # usable everywhere below.\n\n    \n    if request_angle is None:\n        Drive.result_code = results.PROBLEM\n        log(log_level.END, 'GSTA',\n            \" | req_angle is None: Returning!!!\" )\n        return\n\n    log(log_level.START, 'GSTA',\n        \" | req_angle:\", request_angle,\n        \" | spin_left:\", spin_left, \n        \" | spin_right:\", spin_right )\n\n    while True: \n        yaw, actual_yaw = get_yaw(request_angle) \n        correction = request_angle - yaw                # how far off request_angle are we\n\n        # are we there yet!!!!\n        if abs(correction) <= Drive.spin_accuracy:      # are we within accuracy\n            motor_pair.stop(Drive.motor_pair_id , \n                                    stop=motor.HOLD)    # hold will activly hold position\n            sleep(Drive.settle_time)\n\n            log(log_level.ALL, 'GSTA', \n                \" | request_angle: \", request_angle, \n                \" | actual_yaw:\", actual_yaw,\n                ' | yaw:', yaw, \n                \" | corr: \", correction,\n                \" | speed: \", speed)\n            break                                       # get out of the loop, we are there. \n\n        turn_text = 'Unk'                               # shows the decision, right/left\n\n                                                        # spinning is oposite of going straight\n        if spin_right == True:                          # to spin right, right goes in reverse,\n            turn_direction = -1                         # left in forward\n            turn_text = 'force-right'\n        elif spin_left == True:                         # to spin left, left goes in reverse,\n            turn_direction = 1                          # right goes forward\n            turn_text = 'force-left'\n        elif correction >= 0:                           # we want to go right\n            turn_direction = -1                         # spin right, right goes backward\n            turn_text = 'right'\n        else:\n            turn_direction = 1                          # we want to go left\n            turn_text = 'left'                          # spin left, left goes backward\n\n        if abs(correction) > Drive.spin_far_range:      # how far from target can we spin fast\n            spin_speed = Drive.spin_far_speed           # we are far from target, spin fast\n        else:\n            spin_speed = Drive.spin_near_speed          # we are near target, slow down\n\n        speed = spin_speed * turn_direction             # apply direction to our speed. \n\n        log(log_level.ALL, 'GSTA',\n            \" | req_angle:\", request_angle,\n            \" | actual_yaw:\", actual_yaw,\n            \" | yaw:\", yaw,\n            \" | turn:\" , turn_direction, \n                    \"(\", turn_text,')',\n            \" | cor:\", correction,\n            \" | speed:\", speed)\n\n\n        velocity = int(\n            calc_pct_value(Drive.motor_max_velocity,    # calc the velocity, make it an int\n                        speed))\n\n        motor_pair.move_tank(Drive.motor_pair_id,       # apply velocities to the motors\n            velocity * Drive.motor_left_direction ,     # we use motor_pair so they start\n            velocity * Drive.motor_right_direction  )   # and stop, together\n\n    sleep(Drive.settle_time)                            # let robot settle, it is moving\n    #if Drive.use_linegraph == True:\n    #    gyro_drive_plot(correction, yaw, angle, last_step = True)\n    Drive.result_code = results.TARGET_REACHED\n    log(log_level.ALL, 'GSTA',\" | Target Reached\")\n\n    yaw, actual_yaw = get_yaw(request_angle)            # get the yaw to see where we ended.\n\n    log(log_level.END, 'GSTA',\n        \" | request_angle: \", request_angle, \n        \" | actual_yaw: \", actual_yaw,\n        \" | corr: \", correction,\n        \" | yaw \", yaw,\n        \" | spin_left:\", spin_left,\n        \" | spin_right:\", spin_right,\n        \" | speed:\", speed )\n\n\ndef get_result_code_text():\n\n    if Drive.result_code == results.CODE_RESET:\n        code_text = 'Result Code Reset (' + str(Drive.result_code) + ')'\n\n    elif Drive.result_code == results.TARGET_REACHED:   \n        code_text = 'Target Reached (' + str(Drive.result_code) + ')'\n\n    elif Drive.result_code == results.TIMED_OUT:\n        code_text = 'Timed Out (' + str(Drive.result_code) + ')'\n\n    elif Drive.result_code == results.WAYPOINT_DETECTED:\n        code_text = 'Waypoint Detected (' + str(Drive.result_code) + ')'\n\n    else:\n        code_text = 'Unknown Code (' + str(Drive.result_code) + ')'\n\n    return code_text\n\n\n\ndef log(msg_level, source, *args):                      # args is the rest of the vales.\n\n    if Drive.log_source_filter != \"\":                   # are there any source filters?\n        if Drive.log_source_filter.find(source) < 0:    # do not show this source\n            return                                      # get out\n\n    if msg_level <= Drive.logging_level:                # show an below the level\n                                                        # notice the order of the list. \n        levels = [\"OFF\", \"PROBLEM\", \"END\", \"STEP\", \n            \"START\", \"ALL\"]\n\n        # get he message type, may be unknown\n        try:                                            # we try \n            level_name = levels[msg_level] + '.' * 5\n        except:                                         # problem?   \n            level_name = 'UKNOWN - See levels'          # we do this\n\n        level_name = level_name[:5]                     # strip level to only 4 characters\n\n\n        # format the time stamp common look    .        # string manipulation is cool!!!\n        tyme = str(get_elapsed_sec(Drive.program_started_sec)) # get the elapsed sec\n                                                        # example: \"5.34\" string!!!\n        parts = tyme.split('.')                         # split on . to get sec and mills\n                                                        # parts is a list [\"5\",\"34\" ]\n        sec = \"     \" + parts[0]                        # sec now = \"    5\"\n        ms = str(parts[1] + '00000')                    # ms now  = \"3400000\"\n        tyme = sec[-5:] + '.' + ms[:3]                  # glue back together \n                                                        # \"   5.340\" so nice!!! \n\n\n        message = tyme + ' | ' + str(source)  \\\n                       + ' | ' + str(level_name) + ' ' \n\n        for arg in args:                                # read in the list of values\n            message += str(arg)                         # use str to convert any arg to a string\n                                                        # add these to the message\n\n        print(message,'<')                              # add this is the end to help you\n                                                        # split the logs into seperate\n                                                        # lines\n\n\n############################################\n# End of gyro drive functions\n############################################\n\n#####################################################################\n# Gyro Drive Test class\n# this nicely encapsulates all the tests\n#####################################################################\n\nclass gyro_drive_tests:\n\n    # this is the class constructor that builds this instance\n    # these value are passed to the individual tests. \n    # soem fo the tests allow you to enter an override. \n    def __init__(self, speed = 50, length = 50, \n            request_angle=0, loops=2, rev_speed = 30):\n        self.speed = speed\n        self.length = length\n        self.loops = loops\n        self.request_angle = request_angle\n        self.rev_speed = rev_speed\n\n    def time_demo(self):\n\n        \"\"\"\n        Shows you how we manipulate time on the robot. \n        It really is more like seconds as our missions do\n        not last very long. \n\n        There are no parameters. It will show you how we \n        calculate seconds since the beginning of the program, \n        since the beginning of a function. \n\n        \"\"\"\n\n        sleep(5)\n        print('Showing Program Time ------------------------')\n        for p in range(0,3):\n            print(\"Pass: \", p )\n            current_sec= get_hub_sec()                                  # capture current system seconds\n            print(\"Current sec:\", current_sec)\n            print(\"Current min:\", current_sec/60)                       # convert sec into minutes\n            print(\"PGMStartSec:\", Drive.program_started_sec)\n            elapsed_sec = get_elapsed_sec( Drive.program_started_sec)\n            print(\"elapsed Seconds:\" , elapsed_sec)\n            print(\"sleeping for 1\")\n            print(\"\")\n            sleep(1)\n\n\n        # creating our own local timer                                  # gyro_drive uses this idea to allow you\n                                                                        # to drive over a designated time\n                                                                        # and supports the timeout feature\n\n        local_start_sec = get_hub_sec()                                 # new local starting point\n        print('LocalTimer Start:')\n        print(\"Sleep for 4.5\")\n        sleep(4.5)\n\n        current_sec=get_hub_sec()\n        elpased_sec = get_elapsed_sec(local_start_sec)                  # this get different from when\n        print(\"CurrentSec..:\", current_sec)\n        print(\"PGM Start Sec.:\", Drive.program_started_sec)\n        print(\"Local Elap Sec:\", elpased_sec)\n        print(\"PGM Elaps Sec.:\",\n                current_sec - Drive.program_started_sec )\n\n        print('Done..')\n\n\n    def spin_to_angle_test(self, req_angle = None, sleep_duration = 2):\n        \"\"\"\n        Shows you how the robot can accuratly spin to many \n        angles. \n\n        Parameters:\n        req_angle   : (default None) A specific angle you would \n                        like to see it spin to. This will help you \n                        understand the, 180, and 360 degree compasses. \n\n                        If None it will spin to many angles as\n                        specified in the list of angles below. \n\n                        If Drive.use_yaw_360 = True, you will see the\n                                full list of angles. \n                                \n                        If Drive.use_yaw_360 = False, you will see the \n                                smaller list\n\n        sleep_duration:  This is defaulted to 2 seconds. You can change\n                            this to pause longer between angle chamges. \n\n        Returns:\n        Nothing\n\n        \"\"\"\n\n        global Drive\n\n        angle_list = [0]\n\n        if req_angle is not None:\n            req_angle = abs(req_angle)                      # force it positive\n            if req_angle < 180:                             # easier if it is positive\n                Drive.use_yaw_360 = False\n            else:\n                Drive.use_yaw_360 = True\n\n            using_message = \"angle: +/- \" + \\\n                                str(req_angle) + ' only!'   # build a message fro where we are\n\n            angle_list = [req_angle, req_angle * -1, 0 ]    # build a list of angels based upon the \n                                                            # angle that was passed \n\n        elif Drive.use_yaw_360 == False:                    # show 180 degree compass\n                                                            # we included 179 and -179 to show\n                                                            # what happwns if you get too close\n                                                            # to 180 degerees. \n            angle_list = [45, -45, 90, -90, 135, -135, 180, -180, 0] # hit 180 and it goes spinny!!!!\n            using_message = \"180 compass\"\n            print(using_message)\n        else:\n            angle_list = [45, -45, 90, -90, 135, -135, \n                         180, -180, 270, -270, 360, -360, \n                         390,-390, 450, -450, 0]            # list of angle Google: python list\n            using_message = \"360+ compass\"\n            print(using_message)\n\n        display.text(\"Using \" + using_message)\n        sleep(2)\n\n\n        for angle in angle_list :                           # loop though all the angles\n            display.text(\"Spin to Angle: \" + str(angle) )\n            gyro_spin_to_angle(angle)                       # call the function\n\n            yaw, actual_yaw = get_yaw(angle)                # now we get the yaw. \n            display.text(\"At angle: \" + str(angle) + \n                        ' Yaw:' + str(yaw) + \n                        ' actual_yaw: ' + str(actual_yaw) )\n\n            light_matrix.write(str(yaw))                    # show the yaw on the light display\n\n            print(\"At angle: \" + str(angle) + \n                    ' | Yaw: ' + str(yaw) + \n                    ' (' + str(actual_yaw) + ')' )\n            sleep(sleep_duration)\n\n        display.text(\"Done...\")\n\n\n\n    def yaw_test_graph(self,reset=True):\n\n        \"\"\"\n        Creates a line graph of the gyro yaw settings.\n        This runs for 60 seconds and will show you if there\n        is any drift in the Gyro Yaw value.\n\n        Parameters:\n        reset (bool):True / False to reset the yaw before\n                        you graph. It has a default of True. So\n                        if you call yaw_test_graph(), reset it\n                        set to True.\n\n\n        Returns:\n        Nothing\n\n        \"\"\"\n        \n        msg = \"\"\"\n        yaw_test_graph():\n            Test started DO NOT TOUCH THE ROBOT DURING THE TEST. \n            It is getting the yaw once a second for sixty (60) \n            seconds to see if your yaw is drifting at all. \n            DON'T PANIC - There are ways to fix it. \n        \"\"\"\n        print( msg )\n\n        function_start_sec = get_hub_sec()                  # capture the start point\n\n        Drive.use_linegraph = True                          # trun on the line graph\n        linegraph.clear_all()                               # turn on line graph and clear it\n\n        if reset == True:                                   # test to see if reset is True\n            motion_sensor.reset_yaw                         # if True, reset the motion sensor.\n                                                            # 0 degrees will be whatever position the\n                                                            # robot is in.\n\n        for i in range(61):                                 # Google: Python for loop\n                                                            # Google: python range\n            if i > 0 :                                      # skip sleep if i=0, capture a base measure at 0\n                sleep(1)                                    # then wait 1 sec before each test\n\n\n            robot_angles = motion_sensor.tilt_angles()      # Returns a tuple containing yaw, pitch and roll \n                                                            # values as integers. Values are decidegrees\n                                                            # Google: python tuple\n            raw_yaw = robot_angles[0]/10                    # yaw [0] is the first item in the tuple. \n                                                            # /10 shifts it right to degrees\n                                                            # 104 converted into 10.4 degrees\n\n            raw_yaw *= -1                                   # we flip yaw so we match what block does.\n            int_yaw = int(raw_yaw)                          # integer version of yaw, no decimal\n            rnd_yaw =round(raw_yaw)                         # what do this mean? we rounded it. Google it \n\n            elapsed_sec = get_elapsed_sec(function_start_sec) # get seconds since function started\n            elapsed_sec = int(elapsed_sec)                  # convert elapsed_sec into an integer\n                                                            # so no decimal to make graph messy\n\n            linegraph.plot(color.RED,    elapsed_sec, raw_yaw)  # raw\n            linegraph.plot(color.GREEN,  elapsed_sec, rnd_yaw)  # rounded?Google: python round\n            linegraph.plot(color.PURPLE, elapsed_sec, int_yaw)  # as an integer (no decimal)\n\n            if i > 0 :\n                print(\"Elapsed Sec: \" + str( elapsed_sec))\n\n\n        linegraph.show(True)\n\n\n    def drive_accuracy_test(self):\n\n        \"\"\"\n        This test is designed to see if your settings will\n        accuratly drive the requested distance in both forward\n        and reverse speed. This is becasue some heaver robots \n        will not handle fast speeds in reverse. \n\n        Experiment with Wheel diameter to dial in your robot's \n        values to meet the marks.\n\n        \"\"\"\n\n        rev_speed = abs(self.rev_speed)                             # make it positive, we will fix below.\n\n        if self.rev_speed > 40:\n            print('Warning: High reverse speeds can cause')\n            print(' overcorrection!!!!Test, Test, Test')\n\n        for l in range(0, self.loops):                              # Google: python for loop\n            print('DACC: loop:',l+1, ' of ', self.loops )\n            print(\"Forward>>>>\")\n            sleep(1)                                                # python version of sleep\n            gyro_drive( 'd', self.length, self.speed, 0 )\n            print(\"Reverse<<<<\")\n            sleep(1)    # python version of sleep\n            gyro_drive( 'd', self.length, -self.rev_speed, 0 )      # lower speed back for accuracy\n        print(\"Done\")\n\n    def drive_test_rectangle(self):\n\n        Drive.use_yaw_360 = True\n\n        for i in range(0, self.loops):\n            gyro_drive( 'd',  200, self.speed,0)    # leg 1, straight at 0 degrees\n            gyro_drive( 'd', 100, self.speed, -90)    # leg 2, turn left or -90 degrees\n            gyro_drive( 'd', 200, self.speed,-180)    # leg 3, turn to -180, head west\n            gyro_drive( 'd', 100, self.speed,-270)    # leg 4, turn right and drive to starting point\n            gyro_spin_to_angle(0)\n\n    def drive_test_square(self):\n\n        Drive.use_yaw_360 = True\n\n        for i in range(0, self.loops):\n            gyro_drive( 'd', 50, self.speed,   0)    # leg 1, straight at 0 degrees\n            gyro_drive( 'd', 50, self.speed, -90)    # leg 2, turn left or -90 degrees\n            gyro_drive( 'd', 50, self.speed,-180)    # leg 3, turn to -180, head west\n            gyro_drive( 'd', 50, self.speed,-270)    # leg 4, turn right and drive to starting point\n            gyro_spin_to_angle(0)                    # leg 5, turn to starting direction, o degrees\n\n\n    def drive_torture_test(self):                   # drive the torture test \n\n        Drive.use_yaw_360 = True\n\n        diag_distance = 71.5\n\n        # start pointing east\n        for i in range(0,self.loops):\n            gyro_drive( 'd', 25, self.speed,   0)     # Go east  for 25\n            gyro_drive( 'd', 50, self.speed, -90)     # go north for 50\n            gyro_drive( 'd', 25, self.speed,   0)     # Go east  for 25\n            gyro_drive( 'd', 50, self.speed,  90)     # Go south for 50\n            gyro_drive( 'd', 25, self.speed, 180)     # go west  for 25\n            gyro_drive( 'd', 50, self.speed, -90)     # go north for 50\n            gyro_drive( 'd', 25, self.speed, 180)     # go west  for 25\n            gyro_drive( 'd', 50, self.speed,  90)     # go south for 50\n            gyro_drive( 'd', 50, self.speed,0)        # Go east for 50\n            gyro_drive( 'd', diag_distance, \n                                    self.speed,-135)  # Go north-west for 71.5\n            gyro_drive( 'd', 50, self.speed,0)        # Go east for 50\n            gyro_drive( 'd', diag_distance, \n                                    self.speed, 135)  # Go south-west for 71.5\n            gyro_spin_to_angle(0)                     # return to 0 degrees\n\n\n    def yaw_demo(self, request_angle = 0):\n        \n        msg = \"\"\"\n        Manually move the robot slowly in each direction.\n        The console will print the yaw and actual_yaw changes.\n        It will sleep for 1 second between printouts.\n        Parameter:  request_angle - What angle +/-540 deg. do you \n                    want to test? Default is 0. \n            Angle below +/- 135 deg. shows 180 deg. compass.\n            Angle above +/- 135 deg. shows 360 deg. compass.\n        \"\"\"\n\n        print(msg)\n\n        request_angle = int(request_angle)                  # make sure our tests work\n\n        while True:\n            sleep(1)\n            yaw, actual_angle = get_yaw(request_angle)\n            yaw = int(yaw)                                  \n\n            msg = \"yaw_demo: target \" + str(request_angle) + \\\n                    \", yaw: \" + str(yaw) + \\\n                    \" (actual \" + str(actual_angle) + ')'\n\n            correction = int(yaw - request_angle)             # how far to get to the req angle. \n\n            if correction > 0:\n                msg += \" << \" + str(abs(correction)) + \" dg.\" # abs -show correction w/o a sign. \n            elif correction < 0:\n                msg += \" >> \" + str(abs(correction)) + \" dg.\" \n            else :\n                msg += \" ON TARGET!!!\"\n\n\n            print( msg )\n\n\n\n###################################\n# End gyro_drive_test Class\n###################################\n\n#################################################\n# spinny Class\n# Designed to drive 1 motor to spin to\n# specific degrees as a certain speed\n# Modify but do not remove\n#################################################\n\nclass spinny:\n    PROBLEM        = -1                                         # If a problem happens. Will also throw an exception.\n    CODE_RESET     = 0                                          # this is reset at the beginning of the gyro_drive functions\n    RUNNING        = 1\n    TARGET_REACHED = 2                                          # robot achieved the desired target\n\n    # used to hold the values when we go async. \n    velocity = 0\n    speed = 0\n    target_deg = 0\n    position = 0\n    async_op = False\n\n    # this is the class constructor                             # Google python class constructor\n    def __init__(self,\n        handle,                                                 # give it a 4 character name\n        port,                                                   # what motor port, use port.enum\n        max_deg,                                                # maximum degrees or motor travel\n        max_vel,                                                # motor maximum velocity\n        accuracy = 1,                                           # target envelope target +/- 1\n        stop_mode = motor.SMART_BRAKE,                          # motor behavior on stop\n        close_degrees = 60,                                     # how close do we shift to slow.\n        close_speed = 10):                                      # speed close to target for accuracy\n\n        self.handle = handle                                    # google python class self\n        self.motor_port = port                                  # we are passing the values\n        self.max_degrees = max_deg                              # you put in here, into class\n        self.max_velocity = max_vel                             # variables. They may have the\n        self.accuracy = accuracy                                # name but the are different.\n        self.close_speed = close_speed                          # self means they belong to the\n        self.close_degrees = close_degrees                      # class\n        self.stop_mode = stop_mode\n\n        # internal fields.\n        self.result_code = spinny.CODE_RESET\n        self.reset()                                            # reset the motor relative start\n                                                                # position. See reset definition\n                                                                # below.\n\n    def get_result(self):                                       # get the last result code.\n        return self.result_code\n\n    def reset(self):\n        motor.reset_relative_position(self.motor_port,0)        # reset the motors relative position to 0\n\n    def get_relative_pos(self):\n        return motor.relative_position(self.motor_port)         # get the relative motor position\n                                                                # notice it references the classes motor port.\n\n    def get_motor_port(self):\n        return self.motor_port                                  # return the class motor port for other methods\n\n    def test(self, position_list, speed=30, loops=1 ):          # allows you to see how far it will move.\n\n        Drive.logging_level = log_level.ALL                     # allow us to see all log levels.\n        Drive.log_source_filter = 'TEST'                        # while running only show 'TEST' logs\n        # we replaced handle with 'TEST'                        # this will silence all the others.\n        # so it is the only log to show.\n        log( log_level.START , 'TEST', \"| Demo started...\" )\n\n\n        self.reset()                                            # reset motor relative position\n        for p in range(0,loops):                                # perfrom the x many loops\n            log( log_level.START , 'TEST',\n                \"Pass: \", p+1, \" of \", loops)\n\n            for position in position_list:                      # loop through the positions\n\n                log( log_level.STEP ,'TEST',\n                    \" | To pos: \" , position , \"%\",\n                    \" (want \",\n                    calc_pct_value(self.max_degrees,\n                        position),\n                    \" | At speed \", speed)\n\n                self.run(position, speed)                       # run spinny, position% of degrees\n\n                sleep(2)\n\n                log( log_level.END ,'TEST',\n                    \" | At pos: \" , position , \"%\",\n                    \" (actual \", self.get_relative_pos(),\n                    ' deg.) of +/- ', self.max_degrees,\n                    \" deg.\")\n                sleep(2)\n\n\n    def spin_motor(self):\n\n        while True:                                                # this loop moves the motor.\n            direction = 0                                        # seed to stop if pass through tests\n\n            \n\n            our_relative_deg = \\\n                    motor.relative_position(self.motor_port)        # get where we are now\n\n            self.target_dist = abs(our_relative_deg - self.target_deg)        # how close we are to the target?\n\n\n            '''log( log_level.END ,self.handle,\n            \" | run \",\n            \" | position: \", self.position, \"%\",\n            \" | target deg: \" , self.target_deg,\n            \" | target_distance \", self.target_dist,\n            \" | relative deg \", our_relative_deg)'''\n\n            # target envelop - show on a horizontal number line    # we use abs here. Target envelope is 1,0,-1\n            if self.target_dist <= self.accuracy: break                    # are we within 1 degree of the target?\n            elif our_relative_deg <= self.target_deg: direction = 1    # are we below the target, we move up?\n            elif our_relative_deg >= self.target_deg: direction = -1    # are we above the target, we move down?\n\n            if self.target_dist < self.close_degrees and \\\n                                self.velocity != self.close_velocity:        # we are close, now use close_velocity\n                self.velocity = self.close_velocity                        # we will use this until we hit envelope.\n\n            motor.run(self.motor_port, int(self.velocity) * direction)# update the motors velocity.\n\n            if self.async_op == True: return                            # bug out when using async\n\n        motor.stop(self.motor_port, stop=self.stop_mode)                # when we stop we apply the stop_mode\n\n        self.result_code = spinny.TARGET_REACHED\n                                                                        # these are defined under motor\n        log( log_level.END ,self.handle,\n            \" | run \",\n            \" | position: \", self.position, \"%\",\n            \" | target deg: \" , self.target_deg)\n\n    @staticmethod\n    def spin_multi_motors(motor_list, async_op=False):\n        total_spinnys_finished = 0\n        total_spinnys = len(motor_list)                                 # how many spinnys do I have\n        if total_spinnys < 1:                                           # no spinnys were passed in the list\n            return\n    \n        while total_spinnys_finished < total_spinnys :\n            total_spinnys_finished = 0                                  # reset here\n            for spinny_instance in motor_list:                          # check each spinny in the list\n                if spinny_instance.result_code == spinny.RUNNING:       # if we are running\n                    spinny_instance.spin_motor()                        # keep spinning, we do not stay here\n                else:\n                    total_spinnys_finished += 1                         \n            \n            if async_op == True:                                        # in async mode we will be called\n                return                                                  # by an outside loop\n\n\n\n    def run(self, position, speed=10,\n        close_speed_override = None,                            # allows you to override the class versions\n        close_degrees_override = None,\n        stop_mode_override = None,\n        accuracy_override = None,\n        async_op = None):\n\n        \"\"\"\n        spinny.run - Run the motor assigned to the spinny class\n                    You can overide the class settings here.\n                    These will not change the class settings.\n                    You do that when you init it.\n        \"\"\"\n        self.result_code = spinny.RUNNING\n\n        #######################################################\n        # use overrides without changing the class versions.\n        # if overrides came in as not None,\n        # then we want to use them once without\n        # changing the class constructor settings.\n        #######################################################\n        if accuracy_override is not None:                       # user passed a value here so use it\n            self.accuracy = accuracy_override\n                                                                # self version. The self version is not changed\n        if close_degrees_override is not None:\n            self.close_degrees = close_degrees_override\n\n        if close_speed_override is not None:\n            self.close_speed = close_speed_override\n\n        if stop_mode_override is not None:\n            self.stop_mode = stop_mode_override\n\n        self.async_op = async_op                                # the passed value has the same name. \n                                                                # but they are different         \n\n\n        self.target_deg = calc_pct_value( self.max_degrees, position)         # convert position% to the target degrees\n\n        # Define the 2 veloocities\n        self.velocity = calc_pct_value(self.max_velocity, speed)         # convert speed% to desired velocity\n\n        self.close_velocity = \\\n                calc_pct_value(self.max_velocity, self.close_speed)      # as we get close to target slow down for accuracy\n\n        log( log_level.START ,self.handle,\n            \" | run \", \" | position: \", self.position, \"%\",\n            \" | speed: \", self.speed, \" | target deg: \" , self.target_deg,\n            \" | accuracy: \", self.accuracy )\n\n        self.spin_motor()\n\n\n###################################\n# End spinny Class\n###################################\n\nmain() # this is where main is called and the program runs. \n\n"}